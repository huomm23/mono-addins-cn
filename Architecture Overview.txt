# Mono.Addins框架概览
 Mono.Addins应用的扩展模型依赖于一下四个概念：

* **Add-in host（插件宿主）:** 可以被插件扩展的应用程序或类库。他的可扩展性通过定义扩展点来体现。
* **Extension point（扩展点）:** 可以提供插件进行注册扩展节点以提供扩展功能的占位符。扩展点可以通过类型名字或者扩展路径来标识。
* **Extension node（扩展节点）:** 一个通过特性进行描述的节点，用来声明一个具体的扩展。 扩展节点是一个类型，他可以声明可以扩展点可以接收的很多类型。
* **Add-in（插件）:** 一个程序集和/或其他文件组成，他可以向一个或多个扩展点上注册新的节点。一个插件也可以是其他插件的宿主。

Mono.Addin定义了一个插件描述模型,插件和插件宿主基于此模型定义所有的扩展信息。插件可以通过XML清单描述,也可以针对程序集和类型自定义特性来描述。

Mono.Addins定义了一系列的API （在Mono.Addins.dll中实现），可以在运行时查询和处理插件扩展信息。

为了阐述这些概念，让我们来看一个基于Mono.Addins实现的简单的程序。

## 一个简单的例子
这个例子要实现是一个可以支持插件扩展的文本编辑器 （Text Editor）， 下图显示了编辑器支持的扩展点， 以及提供扩展的一些插件。



本文的后续章节将解释如何使用Mono.Addins 来针对文本编辑器提供不同类型的扩展。现在让我们从程序的骨架和一个简单的扩展开始。

我们想让应用程序在启动时运行一个自定义命令。其他插件可以使用这个命令，例如，这些插件订阅一个编辑事件， 当编辑操作发生的时候他们可以执行一些自定义操作，或者做一些初始化工作。

插件宿主（The Add-in Host）
文本编辑器有一个TextEditor.exe可执行程序集构成，以下是主要代码：
```
    using System;
    using Mono.Addins;

    [assembly:AddinRoot ("TextEditor", "1.0")]

    class MainClass
    {
        public static void Main ()
        {
            AddinManager.Initialize ();
            AddinManager.Registry.Update ();

            foreach (ICommand cmd in AddinManager.GetExtensionObjects&lt;ICommand&gt; ())
                cmd.Run ();
        }
    }

    [TypeExtensionPoint]
    public interface ICommand
    {
        void Run ();
    }
```
这段代码呈现了一些声明和初始化操作。这些操作在所有的需要扩展的应用程序中都是必须的：

特性 [AddinRoot] 应用到程序集声明，表示这个程序集是插件宿主程序集，插件宿主必须提供标识和版本信息。
AddinManager.Initialize 用来初始化插件引擎。初始化操作必须在任何AddinManager 相关操作之前被调用。
当调用AddinManager.Registry.Update的时候，插件引擎将会扫描应用程序目录（包括其他用户自定义的插件目录）来搜索插件，然后更新内部的插件注册信息来缓存插件信息。
AddinManager.GetExtensionObjects用来查询一个或多个扩展点，他返回一个匹配了扩展点对象列表。
特性 [TypeExtensionPoint] 用来声明一个类型或接口，表示他们是一个可以接收指定类型的对象匹配的扩展点，在这个例子中，我们定义了一个接收命令接口的扩展点。
一个简单的插件
在一个独立的程序集中实现的简单插件:

    using System;
    using Mono.Addins;

    [assembly:Addin]
    [assembly:AddinDependency ("HelloWorld", "1.0")]

    [Extension]
    public class HelloCommand: ICommand
    {
        public void Run ()
        {
            Console.WriteLine ("Hello World!");
        }
    }
特性 [Addin] 标识当前程序集是一个可以被插件系统自动组织管理的插件。特性[AddinDependency]声明所扩展的插件宿主，这种声明是必须的。需要说明的是：插件可以扩展多个插件宿主，也可以扩展其他提供了扩展点的插件。特性AddinDependency 必须指定具体的插件/宿主的标识和版本号。

通过定义在类上定义 [Extension]特性，我们为扩展点上的类型声明了一个扩展节点。扩展点类型通过声明的基类和接口来约束。因此在这个例子中，实现了接口ICommand的类型将会被注册到指定ICommand的扩展点上。如果一个类实现了多个接口，我们可以通过指在特性中指定具体的类型名字来选择需要扩展的扩展点。，例如: [Extension (typeof(ICommand))].

可扩展的应用程序框架
可扩展的应用程序至少会由一个可执行程序和一个类库组成。可执行程序是应用程序驱动器并实现了重要的逻辑。类库提供一个定义了接口以及可供插件应用或继承的基础类的公共API， 因此基础框架应该是这样的：

[/[images/500px-Addin-arch1.png]]（图像显示不了 :( 。。。）

Mono.Addins 基于强类型扩展模型，在这个模型中，扩展应用程序必须明确的声明他们支持的所有扩展点，每个扩展点必须定义他们可以接收的类型信息。所有的这些可扩展的信息建立和组成我们叫他插件的根(add-in root)。

插件根（Add-in roots）
可扩展的应用程序必须提供一个插件根，也可以提供多个插件根。定义多个插件根对于多个模块的应用程序的组装是有意义的。 用这种方式可以实现针对应用程序特定模块的插件集合。例如，一个应用程序需要在一个程序集中实现一些逻辑，在另一个程序集中实现GUI部分。 这种情况下就可能需要针对逻辑程序集和GUI程序集分别构建独立的插件扩展，这些插件要么扩展逻辑程序集要么扩展GUI程序集要么同时扩展他们两个：



为了满足这种类型的框架结构， 插件根必须拥有一个独一无二的标识（unique identifier）。 Ad插件必须通过ID指定他们需要扩展的具体的插件根。插件根也可以有一个版本号（version number）, 这个版本号可以用来确保他们所提供的扩展点和扩展实现之间的一致性。

插件根可以被绑定到一个或多个（可执行程序或者类库）程序集中，复杂的应用程序可能需要多个应用程序组成，因此，谨慎的去决定哪些可以设计为插件根哪些不可以是非常重要的。

例如：



在这个例子中，一个应用程序由两个可执行程序组成：一个控制台应用程序，一个图形界面应用程序。两个应用程序共享了一些相同的逻辑库， GUI应用程序拥有GUI库和一个组件库。这个应用程序定义了两个插件根：

由两个程序集组成的逻辑插件根: Logic.dll 和 LogicHelper.dll。因为两个程序集都是类库，所以他们可以被控制台和GUI应用程序所重用。
GUI插件根只由一个GUI类库构成。
插件根包含的程序集基本上有两个方面的前提：

程序集需要定义一些供插件实现的类或者接口。
程序集可以装载其他插件根。
Mono.Addins 提供了集中途径来声明插件根以及他们要绑定到的程序集。这些途径在插件和插件宿主的章节描述的比较详细，但是概括下来主要有以下三种方式：、

通过创建一个add-in 清单文件（一个 带有 .addin 扩展名的XML文件）。
通过创建一个add-in 清单文件，然后将它作为资源嵌入到程序集中。
通过提供对程序集提供[assembly:AddinRoot] 特性。
前两种情况下， 清单文件中的一个 Runtime 节点部分可以用来描述引用add-in 根包含的其他程序集。后两种情况下，其他程序集的引用可以通过特性[assembly:AddinAssemblyInclude]来实现。

插件根需要一个主文件。当需要一个独一的清单文件的时候，主文件就是清单文件。当需要一个嵌入到程序集中的清单文件或者当需要用到[AddinRoot] 特性的时候，主文件就是一个程序集。只有主文件能够包含其它插件根中的文件。

插件
插件跟插件根有很多相似的地方，因为插件可以被当作其他插件的插件宿主应用。所以，插件可以有一些程序集和其他文件组成，他们可以通过独立的清单文件进行描述，可以被iq嵌入到程序集中的清单描述，可以被程序集的[assembly:Addin] 特性描述。

下面这张图展示了一个插件由两个程序集组成，被其他插件扩展：



插件根和插件被一个相同的插件描述模型所描述，但是插件引擎对他们的处理是不同的。插件根程序集应用程序宿主装载，插件被插件引擎动态发现和装载。

可扩展的类库（Extensible libraries）
当一个插件宿主全部由类库组成的话，那么我们所面对的是一个可扩展的类库。这个时候恰到好处的封装扩展点到一个类库是非常重要的，因为他会被应用程序当作其他类库一样去使用。

Mono.Addins 支持相同插件根在不同位置上的多个副本。当装载一个插件根的时候，插件引擎将会自动处理扩展具体版本的插件根的插件的装载工作。

例如：有人实现了解析源代码文件的通用类库叫做NParser。 NParser 提供了：

解析文件的通用API.
一个支持新语言解析的扩展点。
任何应用程序都有可能通过连接NParser为私有的程序集并应用它，或者通过GAC调用它。在这种情况下，这个类库的插件会被从全局注册表中装载，除非应用程序指定具体需要注册的具体的插件。

两个月前最后一次被Lluis Sanchez更新。
